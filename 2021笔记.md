### 音视频直播相关
- RTMP协议：（Real Time Message Protocal）
    一方面是它是基于 TCP 传输，非公共端口，可能会被防火墙阻拦；
    另一方面，也是比较坑的一方面是 RTMP 为 Adobe 私有协议，很多设备无法播放，特别是在 iOS 端，需要使用第三方解码器才能播放。
- HSL协议：（HTTP Live Streaming）m3u8
    实时性差，延时高。
    文件切片，产生海量小文件，对存储有一定挑战
- FLV
    其格式相对简单轻量，不需要很大的媒体头部信息。整个 FLV 由 The FLV Header, The FLV Body 以及其它 Tag 组成。因此加载速度极快。采用 FLV 格式封装的文件后缀为 .flv。
    适用于拉流端

连麦问题
- 音频混流，主播将自己的声音与连麦者的声音做混音
    一般是建立连麦后主播，向cdn推送原始音视频流，从cdn上拉取对方音视频流在本地合成并进行回声消除，降噪
    主播主要负责： 画面合成、回声消除、降噪、混音。
- 视频混流，主播将自己的画面与连麦者的画面做视频合成。
- 降噪，去除直播环境中的噪音，啸叫。
- 回声消除，消除扬声器和麦克风的近端回声。
- 低延迟互动，延迟抖动500ms~800ms之间，保证主播和连麦者之间能够实时音视频互动。

音视频延迟
在普通的网络环境下,flv.js播放http-flv的视频流延迟大概在3~5秒左右,对于实时性要求比较高的场景,显然是不适用的,那么怎么才能降低延迟呢? 通过对buffered(缓冲区末尾)和currentTime(当前播放位置)的比较,发现差值大概在1.8秒左右,这时候就需要我们定时检测`currentTime`和`buffered`的差值,然后手动跳帧,使currentTime和buffered同步(PS:这两个值在Player对象中可以获取到,可以查看我的上一篇帖子:vue使用flv.js(bilibili)拉流),代码如下:
```js
setInterval(() => {
    if (this.player.buffered.length) {
    let end = this.player.buffered.end(0);//获取当前buffered值
    let diff = end - this.player.currentTime;//获取buffered与currentTime的差值
    if (diff >= 0.5) {//如果差值大于等于0.5 手动跳帧 这里可根据自身需求来定
        this.player.currentTime = this.player.buffered.end(0);//手动跳帧
    }
    }
}, 2000); //2000毫秒执行一次
```
断流重连
视频直播时,有时候会遇到视频loading,卡顿,有可能是本地网络波动或者服务端流断开,我们可以通过监听flvjs.Events.ERROR来判断连接是否已经断开,继而进行断流重连,代码如下:
```js
this.player.on(flvjs.Events.ERROR, (errorType, errorDetail, errorInfo) => {
    console.log("errorType:", errorType);
    console.log("errorDetail:", errorDetail);
    console.log("errorInfo:", errorInfo);
    //视频出错后销毁重新创建
        if (this.player) {
        this.player.pause();
        this.player.unload();
        this.player.detachMediaElement();
        this.player.destroy();
        this.player= null;
        this.createPlayer(videoElement, this.url);
    }
    });
```
画面卡死
如果控制台没有错误信息,而且查看network发现视频流没有断开,但是画面一直在loading或者卡住不动,我这边的原因是服务端推流突然断开,然后在很快的时间内继续推流,这个时候因为客户端的超时时间还没有结束,流会继续推送到原链接,这个时候我们的视频会卡在掉线的那个时间,不会继续播放.这个时候我们就需要监听推流的decodedFrame,如果decodedFrame不再发生变化,我们就销毁掉该实例并进行重新连接,代码如下:

```js
this.player.on("statistics_info", function (res) {
    if (this.lastDecodedFrame == 0) {
        this.lastDecodedFrame = res.decodedFrames;
        return;
    }
    if (this.lastDecodedFrame != res.decodedFrames) {
        this.lastDecodedFrame = res.decodedFrames;
    } else {
        this.lastDecodedFrame = 0;
        if (this.player) {
            this.player.pause();
            this.player.unload();
            this.player.detachMediaElement();
            this.player.destroy();
            this.player= null;
            this.createPlayer(videoElement, this.url);
        }
    }
    });
```
## html

### 1.实现一个大小为父元素一半的正方形
    利用padding值的单位为百分比的话，是以父级元素的宽作为参考的。
```css
.outer {
    width: 300px;
    height: 500px;
}
.inner {
    width: 50%;
    padding-bottom: 50%;
}
```

### 2.实现一个进度条，进度条中有一串文字，当进度条于文字重叠后文件要与进度条反色

## js基础

### 1.列举你所知道的类型判断的方法？
- typeof： 同样是引用类型 数组和函数的判断分别是 object function，所以不准确
- instanceof: 可能会被修改
```js
class PrimitiString {
    static [Symbol.hasInstance](x) {
        return typeof x === 'string'
    }
}
// 实现 instanceof
function myInstanceof(left, right) {
    const prototype = right.prototype
    left = left.__proto__
    // left是不是能够在原型链上找到right.prototype
    while(true) {
        if (left === null || left === undefined ) return false
        if (left === prototype) return true
        left = left.__proto__
    }
}
```
- constructor判断： 对于null 和undefined 无法判断

最终方案：Object.protoType.toString
```js
function isType(item, type) {
    return Object.prototype.toString.call(item) === [`object ${type}`]
}
```

### 2.深拷贝
使用JSON.parse(JSON.stringify(xxx))进行深拷贝的局限性：
- 会忽略undefined和symbol和函数
- 对于循环引用直接报错

自己实现简单的deepClone

```js
function deepClone(obj, cache = new WeakMap()) {
    const isObj = o => typeof o === 'object' && o !== null;
    if (!isObj(o)) return;
    if (cache.has(obj)) return cache.get(obj);
    let target = Array.isArray(obj) ? [...obj] : {...obj};
    cache.set(obj, target);

    Reflect.ownKeys(obj).forEach(key => {
        if (isObj(obj[key])) {
            target[key] = deepClone(obj[key]);
        } else {
            target[key] = obj[key];
        }
    })

    return target
}
```

### 3.实现一个精准的setInterval

```js
function setInterval(callback, interval) {
    let timer, startTime, endTime;
    const now = Date.now;
    startTime = endTime = now()

    function loop() {
        timer = requestAnimationFrame(loop);
        endTime = now()
        if (start - endTime > interval) {
            startTime = endTime = now()
            callback(timer)
        }
    }

    timer = requestAnimationFrame(loop)

    return timer;
}
```

### 4.为什么会产生变量提升
- 提高性能 解析和预编译中变量提升可以提高性能，让函数可以在执行时预先给变量分配栈空间
- 容错性更好 提高容错率，是一些不规范的代码也可以执行

###  5.原型链的理解
原型链.drawio

```js
// Object instanceof Function
Object.__proto__ === Function.prototype

// Function instanceof Object
Fucntion.__proto__.__proto__ === Object.prototype

// Object instanceof Object
Object.__proto__.__proto__ === Object.prototype

// Function instanceof Function
Function.__proto__ === Function.prototype
```

### 6.垃圾回收机制
1. 引用计数方式 老的浏览器使用
2. 标记清除方式 v8正在使用的

v8使用标记清除
生命周期的长短来分，新生代（副垃圾回收器）和老生代（主垃圾回收器）
新生代：
储存空间小，不能存放大对象
- 成为副垃圾回收器：对象区、空闲区，当对象区满了遍历对象进行垃圾标记，把活动的对象区复制到空闲区，然后和对象区对调，完成垃圾回收，当然gc2次以上仍然存活，则移至老生代

老生代：
空间大，存活时间长。新生代2次gc仍然存活的对象
- 成为主垃圾回收器：采用标记清除算法进行垃圾回收，先将所有存活的对象向一端移动，然后直接清理掉这一端以外的内存。
v8


### 7.实现一个jsonp
```js
function autoJsonp() {
    const script = document.createElement('script')
    script.type = 'text/javascript'
    script.src = 'http://xxx?callback=jsonp'

    document.body.append(script)

    function jsonp(res) {
        console.log('res', res)
    }
}
```
### 8.实现一个装饰器
```js
function setEvent(name, params) {
    return function factory(target, key, description) {
        const fn = description.value;
        description.value = function(...arg) {
            // do you want
            fn.call(this, ...arg)
        }
    }
}
```
```js
// 节流函数，装饰器写法
function throttle(time) {
    const pre = Date.now()

    return function (target, name, description) {
        const fn = description.value

        if (typeof fn === 'function') {
            description.value = function (...arg) {
                const now = Date.now();

                if (now - prev > time) {
                    fn.apply(this, arg)

                    prev = Date.now()
                }
            }
        }
    }
}
```
### 实现js 继承
```js
// 用es5实现继承，寄生组合继承
function inherit(subType, superType) {
    // 第一步 创建对象，创建父类原型的一个副本
    let prototype = Object.create(superType);
    // 第二步 增强对象，弥补因重写原型而失去的默认的constructor 属性
    subType.constructor = subType;
    // 第三步
    subType.prototype = prototype;
}
```
```js
// class的extends的实现
function inherit(subType, superType) {
    // 创建对象，创建父类原型的一个副本
    // 增强对象，弥补因重写原型而失去的默认的constructor 属性
    // 指定对象，将新创建的对象赋值给子类的原型
    subType.prototype = Object.create(superType, {
        constructor: {
            value: subType,
            enumerable: false,
            writable: true,
            configurable: true,
        }
    })

    subType.__proto = superType;
}
```
### new 具体做了什么,实现一个new
```js
function create() {
    var obj = new Object();
    var context = [].shift.call(arguments);
    obj.__proto__ = context.prototype;
    var res = context.call(obj, arguments)
    return typeof res === 'object' && res !== null ? res : obj;
}
```
```js
function newOperator(ctor){
    if(typeof ctor !== 'function'){
      throw 'newOperator function the first param must be a function';
    }
    // ES6 new.target 是指向构造函数
    newOperator.target = ctor;
    // 1.创建一个全新的对象，
    // 2.并且执行[[Prototype]]链接
    // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。
    var newObj = Object.create(ctor.prototype);
    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);
    // 除去ctor构造函数的其余参数
    // [1,2,3] => [2, 3]
    var argsArr = [].slice.call(arguments, 1);
    // 3.生成的新对象会绑定到函数调用的`this`。
    // 获取到ctor函数返回结果
    var ctorReturnResult = ctor.apply(newObj, argsArr);
    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null
    var isObject = typeof ctorReturnResult === 'object' && ctorReturnResult !== null;
    var isFunction = typeof ctorReturnResult === 'function';
    if(isObject || isFunction){
        return ctorReturnResult;
    }
    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。
    return newObj;
}
```

### 严格模式有什么特点
- this是undefined
- 不能用with，aguments不能修改
- 变量需要先声明

### 作用域链的理解
答：作用域链的本质上一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前
端始终都是当前执行上下是文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。
当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

### 给所有元素加上随机颜色outline
```js
[].forEach.call($$("*"),function(a){a.style.outline="1px solid #"+(~~(Math.random()*(1<<24))).toString(16)})
```

### 动态加载js文件的方法
1. html5中新增async(ie9以上;并且只能用于外部脚本js的引入)
2. html4中defer属性(只能用于外部脚本js的引入)
3. 利用ajax请求js的代码并用eval执行
4. 动态创建script标签
5. 用iframe引入js
```js
var iframe = document.createElement('iframe')
document.body.appendChild(iframe)
var doc = iframe.contentWindow.document
doc.open().write('<body onload=function()>');
doc.close()
```
6. requirejs
7. import
8. define
 async和defer不同之处是async加载完成后会自动执行脚本，defer加载完成后需要等待页面也加载完成才会执行代码

### 0.1 + 0.2 为什么不等于0.3
计算机都是用二进制表示数据的：**十进制整数转二进制方法：除2取余；十进制小数转二进制方法：乘2除整**
0.1的二进制格式是：0.0001100011....。这是一个**二进制无限循环小数**，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？
在某个精度点直接舍弃。当然，代价就是，0.1在计算机内部根本就不是精确的0.1，而是一个有舍入误差的0.1。当代码被编译或解释后，0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于0.3 的原因。
**二进制能精确地表示位数有限且分母是2的倍数的小数**

### eventloop相关
eventLoop运行机制：
- 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
- 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
- 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
- 主线程不断重复上面的第三步

```js
// 浏览器环境
while (true) {
    宏任务队列.shift();
    微任务队列全部任务();
}
// node
// 外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段.
while (true) {
    // 定时器： 本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数。
    // 待定回调
    // idle,prepare: 仅内部使用
    // 轮询： 检索新的 I/O 事件;执行与 I/O 相关的回调
    // 检测：setInmediate回调
    // 关闭的回调函数： 如socket.on('close', ...)。
    loop.forEach((阶段) => {
        阶段全部任务();
        nextTick全部任务();
        microTask全部任务();
    });
    loop = loop.next;
}
// 在   文件I/O 、 网络I/O中   setImmediate会 先于 settimeout
// 否则一般情况下 setTimeout  会先于 setImmediate
// nexttick优先级高于微任务
```
eventloop之后16.6ms更新一帧，需要做什么事情？
- 当 `Eventloop` 执行完 `Microtasks` 后，会判断 `document` 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。
- 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
- 判断是否触发了 `media query`
- 更新动画并且发送事件
- 判断是否有全屏操作事件
- 执行 `requestAnimationFrame` 回调
- 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面
- 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调

### async/await 本质是什么 ？generator函数如何实现(http://www.alloyteam.com/2016/02/generators-in-depth/)
async/await 是使用Generator和promise结合实现的。
1. asnyc 函数总是返回一个Promise对象，不论函数是否return Promise；
2. await 后面跟着Promise对象，如果不是Promise对象，也会被封装成Promise；
3. async/await 和Promise对象在本质上是一样的
4. await的任何内容都通过Promise.resolve()传递，这样就可以安全的await非原生Promise；
5. 构造函数以及getter/settings方法不能是异步的；

- 一个线程存在多个协程
- Generator函数是协程在ES6的实现
- Yield挂起X协程（交给其它协程），next唤起协程
Javascript 执行引擎仍然是一个基于事件循环的单线程环境，当生成器运行的时候，它会在叫做 caller 的同一个线程中运行。执行的顺序是有序、确定的，并且永远不会产生并发。不同于系统的线程，生成器只会在其内部用到 yield 的时候才会被挂起。
一是要保存函数的上下文信息，二是实现一个完善的迭代方法，使得多个 yield 表达式按序执行，从而实现生成器的特性。
```js
// cojs实现的思路
function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    if (result.done) return;
    result.value(next);
  }

  next();
}
```
#### 为什么Promise是微任务？
promise本质是解决如何处理回调任务
方案1：使用同步任务回调，直到异步任务执行完，在执行后面的任务；
问题：异步任务需要等待，会一直阻塞后面的任务，导致cpu利用率太低了
方案2：使用异步任务回调，讲回调函数放在进行宏任务队列的末尾；
问题：如果宏任务非常长，会导致异步任务会等很久才能执行，造成卡顿，相当于setTimeout
方案3： 使用异步任务回调，放到当前宏任务执行队列后面 ，也就是目前promise使用的方案
另外，如果在微任务中触发微任务，一样会造成方案2的情况

#### Promise什么时候生成和触发？
创建 Promise 时,并不会生成微任务,而是需要等到 Promise 对象调用 resolve 或者 reject 函数时,才会产生微任务 产生的微任务并不会立即执行,而是等待当前宏任务快要执行结束时再执行

## 网络
从输入url到展示
### 1.浏览器缓存策略 以及实际应用
强缓存协商缓存
cache-control/expire
协商缓存
一般请求服务器后，服务器会在资源的返回头部带上
etag: 字符串 和 last-modifed: 时间戳 并返回200
下次请求时先判断有没有etag,
如果有就带上 if-none-match: 上次请求返回的tag 以及 if-modified-since: 上次请求返回来的last-modify
相对来说etag优先级更高。

response:
etag: xxxx1,
last-modifed: 10099

request:
if-none-match: xxxx1
if-modified-since: 10099

实际应用：
- 频繁变动的使用cache-control: no-cache, 配合etag或last-modifined使用
- 不常变化的使用cache-control: max-age=31536000(1年),配合资源文件hash来均衡更新

什么情况会触发from disk cache和from memory cache？
- 强缓存命中时触发
- 在缓存中先去找内存，如果存在则加载，否则查找硬盘，有则加载，否则网络请求

什么是启发式缓存？
-
```js
// Date 减去 Last-Modified 值的 10% 作为缓存时间。
// Date：创建报文的日期时间, Last-Modified 服务器声明文档最后被修改时间
  response_is_fresh =  max(0,（Date -  Last-Modified)) % 10
```

如何解决浏览器缓存仍然存在的问题？？ [答案](https://www.cnblogs.com/cwzqianduan/p/8632009.html)
1. 在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("If-Modified-Since","0")。
2. 在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader("Cache-Control","no-cache")。
3. 在 URL 后面加上一个随机数： "fresh=" + Math.random();。
4. 在 URL 后面加上时间戳："nowtime=" + new Date().getTime();。
5. 如果是使用 jQuery，直接这样就可以了$.ajaxSetup({cache:false})。这样页面的所有 ajax 都会执行这条语句就是不需要保存缓存记录。

三级缓存原理 (访问缓存优先级)
- 先在内存中查找,如果有,直接加载。
- 如果内存中不存在,则在硬盘中查找,如果有直接加载。
- 如果硬盘中也没有,那么就进行网络请求。
- 请求获取的资源缓存到硬盘和内存。
memory cache: 就是将资源缓存到内存中，等待下次访问时不需要重新下载资源，而直接从内存中获取
disk cache: 就是将资源缓存到磁盘中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为CurlCacheManager

### 2.http三次握手，四次挥手以及https
三次握手：
- 客户端发起请求，并将自己状态设成待链接   can u speak en?
    - `Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等 待Server确认。`
- 服务端收到请求，并返回响应，将自己的状态设为待链接  yes,w's wrong?
    - `Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。`
- 客户端接收到信息后，告诉服务端已经接收到了，把自己设置成已连接 ok balabala....
    - `Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。`
- 服务端收到后，将自己设为已连接
- 开始通信

从网卡把数据包传输出去到服务器发生了什么？
- 先从局域网把数据发送到公司的交换机（如果交换机没有缓存本地mac地址和IP地址的映射，此时会通过ARP协议来获得），交换机的好处是可以隔离冲突域（因为以太网用的是CSMA/CD协议,这个协议规定网线上同一时刻只能有一台机器发送数据），这样就可以不仅仅同一时刻只有一台机器发送网络包了
- 然后交换机再将数据发送到路由器，路由器相当于公司网关（我们公司小），路由器具有转发和分组数据包的功能（路由器通过选定的路由协议会构造出路由表，同时不定期的跟相邻路由器交换路由信息），然后这算是经过了物理层，数据链路层（以太网）,开始到网络层进行数据转发了
- 然后路由器转发IP数据报，一般公司的IP地址都会经过NAT转换，让内网的ip也能够访问外网，我们公司我注意了一下是192.168打头的内网ip地址。通过路由器的分组传输，所有数据到达服务器。
然后服务器的上层协议传输层协议开始发挥作用，根据tcp包里的端口号，让服务器特定的服务来处理到来的数据包，并且tcp是面向字节流的(tcp有四大特性，可靠传输、流量控制、拥塞控制、连接管理)，所以我们node的request对象，它的监听事件data事件为什么要用字符串一起拼接起来呢（buffer），就是因为tcp本身就是字节流，request对象使用的data（http层面）是tcp传来的数据块。
- 最后数据由传输层转交给应用层，也就是http服务（或者https），后端经过一系列逻辑处理，返回给前端数据。

四次挥手：
- 浏览器发起断开请求，状态设为待断开
- 服务端接收到请求，并回复，可能还有数据没传完
- 服务器发送完数据后，把自己设成待断开
- 客户端收到后，回复已收到，并断开连接，设为已断开
- 服务端收到后把自己设为已断开

https:
- 浏览器发起https请求，访问服务端443端口
- 服务器收到后，把自己用非对称加密的公钥传输给客户端
- 客户端校验证书（一般是在本地查是否在信任列表，在线查是否有效），确认有效后，生成clientkey，使用对称加密使用数字证书中的公钥加密clientKey并发送
- 服务端收到使用私钥解密出clientkey, 使用对称加密的clientkey加密内容传输

客户端如何校验证书：
- 校验证书颁发机构是否受客户端信任
- 通过CR或OCSR的方式（也就是去线上查）证书是否被吊销
- 对比系统时间看证书有没有过期
- 通过校验对方是否存在证书的私钥，判断证书的网站域名是否与证书颁 发的域名一致

- 可以通过在用户机器上提前安装假的https根证书来欺骗浏览器

发送端应用层->发送端传输层->发送端网络层->发送端链路层->接收端链路层->接收端网络层->接收端传输层->接收端应用层

http请求过程：
- dns: 域名解析阶段
    - 从url中分解出协议名/主机名/端口/对象路径，这个时候第一步就是DNS解析域名
    - 输入https://www.baidu.com 域名，操作系统会先查hosts件是否有记录，有的话就会把相对应映射的IP返回。
    - hosts文件没有就去查本地dns解析器有没有缓存
    - 然后就去找我们计算机上配置的dns服务器上有或者有缓存，就返回
    - 还没有的话就去找根DNS服务器(全球13台，固定ip地址)，然后判断.com域名是哪个服务器管理，如果无法解析，就查找.baidu.com服务器是否能解析，直到查到www.baidu.com的IP地址
    - (其中有转发模式和非转发模式)
    - 浏览器DNS缓存 -> 本机DNS缓存 -> 路由器DNS缓存 -> 网络运营商服务器DNS缓存 （80%的DNS解析在这完成的） -> 递归查询
- tcp: 建立网络请求
    - 把以上结合本机自己的信息，封装成一个http请求数据包
    - 再把http包封装成TCP包，建立链接
- requesting: 发送网络请求
- webserver: 服务器响应处理
- transferring: 数据传输
- 关闭tcp链接
- parsing: 浏览器解析

http2:
1. 是一个彻底的二进制，头部信息和数据体都是二进制，并统称帧。也就是**二进制分帧**。
2. 多路复用。解决头部阻塞问题。
3. 使用数据流方式发送。使用编号标记，一并发送数据包，接收后在组装。
4. 头部信息压缩。另外客户端和服务端都同时维护一张头部信息表，所有信息都存在一张表上，生成索引号，以后就不会发同样字段了，只发送索引号。
5. 服务端推送。
缺点： 由于多个数据流只使用一个tcp链接，它会遵守同一个流量状态控制和拥塞控制。只要有一个数据流遇到拥塞，剩下的数据流就无法发出，这样就导致后续的请求无法发出。另外tcp协议慢启动也需要时间。主要是tcp协议的限制。

http2头部压缩算法：Hpack算法
- 消息发送端和消息接受端共同维护一份静态表和一份动态表（这两个合起来充当字典的角色），
    - 静态表：也就是公用的一些值：如Mehtod: GET status: 200等
    - 动态表：最初是一个空表，当每次解压头部的时候，有可能会添加条目，动态表允许包含重复的条目，动态表大小有严格限制的
- 每次请求时，发送方根据字典的内容以及一些特定指定，编码压缩消息头部，
- 接收方根据字典进行解码，并且根据指令来判断是否需要更新动态表

http2多路复用时，资源互相依赖怎么办：
传输时会标记好依赖的流，父级未加载完成时，子级都是pendding不会执行

http3:
基于udp协议的quic协议，

滑动窗口：
为了控制流，保证发送方和接收方保持一致的接受频率，
接收方接收到一段数据后会跟告诉发送方下一次需要发送多少，从而发送方可以根据接收方的节奏发送，从而保证了tcp的可靠性

#### http1.0和1.1的区别[区别](https://blog.csdn.net/ailunlee/article/details/97831912)
- http1.1中默认使用keep-alive，可以使得多个请求复用同一个tcp链接，但是同一个tcp链接中，请求次序是固定的。
- http1.0 tcp链接无法复用
- http1.0不支持断线续传，1.1支持断点续传,1.1还可以只发送header信息，节约了带宽
- http1.0不支持host域，1.1则支持host域（即虚拟主机）
- http1.0主要使用了if-modified-since,expires来做缓存，1.1中增加了etag，If-Unmodified-Since, If-Match, If-None-Match等多个可供选择的话缓存头来控制缓存
- http1.1中增加了新的状态码；如409资源被永久删除
- 支持websoket
1.1的确定啊
- 没有真正解决头部堵塞问题
- 明文传输，安全性有隐患
- header中携带的内容过多，增加了传输成本
- 默认开启keep-alive，对于一次性请求，在文件被请求后仍然保持很长时间不必要链接会对服务器造成性能压力

### tcp和udp的区别以及使用场景
TCP （Transmission Control Protocal） 传输控制协议
- 面向连接
- 可靠传输
- 只能一对一通信
- 面向字节流
- 首部最小20字节
- 适用于要求可靠传输的应用
UDP （User Datagram Protocol） 用户数据报协议
- 无连接
- 不可靠传输
- 一对一，一对多
- 面向报文
- 首部开销小
- 实时通信，适用于电话、视频、直播等
- 需要使用RUDP来保证可靠性，需要应用层
- 基于udp的协议： RIP DNS SNMP

### 5.cors相关
cors 全程: Cross-origin resource sharing (跨域资源共享)
简单请求和复杂请求：
简单请求：
- 请求方法： get post head
- 请求头参数： Accept  Accept-Language Content-Language Last-Event-ID
- Content-Type: 只限于三个值 application/x-www-form-urlencoded mutipart/form-data text/plain
除此外的其他请求都是复杂请求。

当发出简单请求时会带上**Origin**请求头，当服务器端返回的请求头中不包含**Access-Control-Arrow-Origin**字段时，请求返回会被浏览器拦截，从而抛出错误。
**Access-Control-Arrow-Credentials** 表示允许发送cookie,值只能设为true,若不需要，则不加此字段即可，另外，若需要打开此功能还需要客户端（发送端）的请求上加上参数`withCredentials: true`

复杂请求：
option预检时，头部信息会包含两个特殊字段
`Access-Control-Request-Method: 请求的方法名Put等`： 表示cors用了什么方法
`Access-Control-Request-Header: X-Custom-Header`: 指定浏览器cors请求会发送的额外头部信息

cors支持所有请求
jsonp只支持get请求，优势在于支持老的浏览器

简单请求： 因为执行响应拦截的是浏览器而不是后端程序。事实上你的请求已经发到服务器并返回了结果，但是迫于安全策略，浏览器不允许你继续进行 js 操作，所以报出你熟悉的 blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.。

### 6.什么是websocket？
WebSocket连接过程：
服务端与客户端建立TCP连接(三次握手)、建立HTTP连接
客户端（浏览器）向服务端发送一个请求头包含
```
Upgrade: websocket
Connection: Upgrade
```
的HTTP请求，申请升级到Websocket连接
服务端回应的响应头：
HTTP/1.1 101 Switching ProtocalsConnection: UpgradeUpgrade: websocket
同意升级协议，至此双方将基于WebSocket协议通信

### 7.get和post请求的区别
幂等：HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用
HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。
HTTP POST方法不具备幂等性。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI
// HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。
// 对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。

安全性：
get 参数都待在url中，有更多的机会被泄密
post 参数在body中，相对来说安全一点， 解决这点的手段只能上https

发请求：
从HTTP协议的角度，“请求头”就是Method + URL（含querystring）+ Headers；再后边的都是请求体。
post 需要发送一次请求头，一次请求体
get 只需要发送一次请求
get产生一个tcp数据包，post产生两个
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

长度
get 请求有url长度限制（浏览器限制）
post 可以在body中传输大的  GET只接受ASCII字符，而POST没有限制。

缓存
get会被缓存，post则会重新请求

GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。

[面经](https://mp.weixin.qq.com/s/V2CU9DtZHrIZI9l1G9gA1w)
### 常用的http状态码(101 200 204 301 302 304 307 400 404 500...)
- 1**	信息，服务器收到请求，需要请求者继续执行操作
    - 101 切换协议
- 2**	成功，操作被成功接收并处理
    - 204 返回成功内容为空
- 3**	重定向，需要进一步的操作以完成请求
    - 301 永久移动
    - 302 临时移动
- 4**	客户端错误，请求包含语法错误或无法完成请求
    - 403 没有权限
    - 404 无法找到资源
- 5**	服务器错误，服务器在处理请求的过程中发生了错误
    - 500 服务器错误
    - 502 网关错误
    - 503 服务器超载
### 用户登录流程 JWT原理
- 登录表单 起码传输之前使用md5封装 发送请求
- 后端校验 成功则随机生成uuid作为sessionId将其写入cookie中返回给客户端，并且将模块前缀+该用户id作为key和sessionId 作为值，存入缓存（这里为分布式缓存提供的基础
## Vue 相关
### 1.vue中的nextTick如何实现的
nextTick本质是利用微任务会在宏任务后执行的原理，统一处理
另外，当对同一个属性进行多次修改的时候，其实只会收集到一次watcher，因为watcher.id要一样才会收集进去
```js
// 一个开关
let pendding = false
const callbacks = []

function flushCallbacks() {
    pedding = false
    callbacks.forEach((fn) => {
        fn()
    })
    callbacks.length = 0
}

function nextTick(cb) {
    callbacks.push(cb)

    if (!pendding) {
        pedding = true
        Promise.resolve().then(flushCallbacks)
    }
}
```
nextTick执行顺序
- 元素改变
- 把当前渲染watcher的id加入到has中，并把当前wacher加入到queue中
- 在nextTick中执行flushScheduleQueue, 相当于promise.resolve.then(flushScheduleQueue)
- 把flushScheduleQueue加入到callbacks中，并微任务执行
- 如果有手动nexttick，则把nexttick回调加入到callbacks中
- 依次执行callback
- 执行flushScheduleQueue更新需要更新的视图，即`watcher.run()`
- 如nexttick中仍有修改属性，则继续触发setter，回到流程1
- 因为在手动nextick执行之前已经调用过更新，所以回调中能拿到最新的dom信息
```js
has[id] = true;
queue.push(wacher)
```

### 2.Vue响应式原理
延伸问题：
1. vue是怎么知道数据改变的？
答：vue初始化的时候对数据递归遍历进行了劫持，在set方法中调用了相关函数进行拦截，所以vue知道数据改变了

2. vue在数据改变的时，怎么知道通知哪些视图更新？什么时候更新？
答：在访问熟悉时，vue收集了访问页面的watcher到属性的收集器（dep： __ob__）中，所以当属性更新时只要遍历一遍依赖项执行它就可以了。
props有一个坑：
如果传入子组件的数据问对象（也就是引用类型的话），在子组件中修改props内部的值会导致父组件的值也会被修改，**并且没有任何提示！！**
基本类型： 只有在defineReactive中的一个dep实例收集依赖 / 父组件通知父组件更新，子组件通知子组件更新 / 父组件通知父组件以及子组件更新
引用类型： 有在defineReactive中dep收集的依赖以及针对子项，childObj.dep.depend()也收集了一遍依赖，如果是数组，遍历在收集一遍依赖。原因在于：
对象的子项更新了也要通知更新，数组的子项更新了增删改查了也要通知更新。针对数组，需要重写数组的一些原生方法或者使用set和get达成更新。
1、引用类型会多添加一个 __ob__属性，其中包含 dep，用于存储 收集到的依赖
2、对象使用 __ob__.dep，作用在  Vue 自定义的方法 set 和 del 中
3、数组使用 __ob__.dep，作用在 Vue 重写的数组方法 push 等中

computed如何缓存的？
- 初始化的时候不计算，第二次访问的时候计算，默认lazy为true，再把dirty = lazy
- 然后去调用computed的getter，在里面执行wacher.evalute也就是getter，计算一遍值并把dirty设为false
- 下次在访问的时候就可以直接使用计算结果缓存

computed和页面wacher更新的关系
- pushTarget(页面watcher) -> pushTarget(computedWatcher) -> popTarget(computedWatcher) -> popTarget(页面watcher)
- 这时候computed收集依赖       这时候内部的data收集依赖                                data收集到了页面的watcher
- data的收集器中= [computedWatcher, 页面Watcher]，更新时正序遍历，所有页面能拿到最新的计算属性的值
- 总结： data改变->自己dep中的wacher.update -> computed-watcher由于lazy是true，所以触发了this.dirty=true -> 页面watcher的render -> 读到computed属性 -> computed-wacher 的dirty为true -> computed-watcher.evaluate 重新计算 页面显示的就是最新的值

v-model中如果加入lazy，这回监听blur事件，针对输入法输入会监听copositionstart事件做优化

默认slot会被解析成占位符 vm.$slots.default, 这样就能去到slot内的值

新旧节点相同才会比较它们的子节点

dep 和watcher合作
dep这边只负责收集watcher，只要屌addSub就会收集，但是这个addSub是在watcher类里面管理的。
wacher类里面addDep方法中只有在depIds中没有才会收集当前wacher进去。

vue中的自定义时间本质上还是使用vue全局的eventemitter， 即$emit $on $off $once

### 3. 使用vue.extents实现一个组件
```js
const LoadingConstructor = Vue.extends(LoadingTemplate)

class Loading {
    instance = null
    getInstance() {
        if (!Loading.instance) {
            Loading.instance = new Loading()
        }
        return Loading.instance()
    }

    show() {
        if (!this.instance) {
            this.instance = new LoadingConstructor({el: document.createElment('div')})

            document.body.appendChild(this.instance.$el)
        }
    }

    close() {
        if (this.instance) {
            document.body.removeChild(this.instance.$el)
        }
    }
}

export default Loading.getInstance();
```

### 4.vue组件间通信方式
1. 父传子，通过props传值方式
2. 子传父，通过$emit时间传输
3. 创建一个新的vue实例作为中央事件总线，可以任意跨组件传输
5. 使用vuex全局状态管理 / 使用localStorage传输
6. 使用provide/ inject 方式 本质是inject的时候通过查找$parent的方式
7. 自己实现dispatch和broadcast, 本质还是使用on和emit触发事件，不过这个触发机制在外部而已
    - 注意点： 订阅必须先于发布，也就是说先有on再有emit
    - 实现代码如下

```js
function broadcast(componentName, eventName, params) {
 this.$children.forEach(child => {
  const name = child.$options.name;

  // 递归找到子组件触发
  if (name === componentName) {
   child.$emit.apply(child, [eventName].concat(params));
  } else {
   // todo 如果 params 是空数组，接收到的会是 undefined
   broadcast.apply(child, [componentName, eventName].concat([params]));
  }
 });
}
export default {
 methods: {
  // 向上广播
  dispatch(componentName, eventName, params) {
   let parent = this.$parent || this.$root;
   let name = parent.$options.name;

   while (parent && (!name || name !== componentName)) {
    parent = parent.$parent;

    if (parent) {
     name = parent.$options.name;
    }
   }
   if (parent) {
    parent.$emit.apply(parent, [eventName].concat(params));
   }
  },
  // 向下广播
  broadcast(componentName, eventName, params) {
   broadcast.call(this, componentName, eventName, params);
  }
 }
};
```

### vue如何实现透传
使用`inheritAttrs: false`并结合`v-on="$listeners"`,v-bind的方式进行透传
```vue
<template>
    <el-button
        v-bind="customizedAttrs"
        v-on="$listeners"
    >
        <slot />
    </el-button>
</template>
<script>
export default {
    name: "MyButton",
    // 为了传入的参数不会出现在对应dom的属性上
    inheritAttrs: false,
    props: {
        size: {
            type: String,
            default: "medium",
        },
    },
    computed: {
        customizedAttrs() {
            return {
                size: "medium",
                // 支持传过来的size覆盖默认的size
                ...this.$attrs,
            };
        },
    },
};
</script>
```

### 虚拟dom和真实dom的区别于优化
- 虚拟 DOM 不会立马进行排版与重绘操作
- 虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多DOM节点排版与重绘损耗
- 虚拟 DOM 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 DOM 比较差异，可以只渲染局部

### axios
### 1.为什么 axios 既可以当函数调用，也可以当对象使用，比如``axios({})、axios.get``。
axios作为函数调用时调用的是axios.prototpye.request方法
axios本质是函数，赋值了一些别名方法，比如get、post方法，可被调用，最终调用的还是Axios.prototype.request函数

2. 简述 axios 调用流程。
答：实际是调用的Axios.prototype.request方法，最终返回的是promise链式调用，实际请求是在dispatchRequest中派发的。

3. 有用过拦截器吗？原理是怎样的？
- 请求和响应的拦截器可以写Promise。
- 如果设置了多个请求响应器，后设置的先执行。
- 如果设置了多个响应拦截器，先设置的先执行。
- 拦截请求 -> 执行请求 -> 拦截响应
**用axios.interceptors.request.use添加请求成功和失败拦截器函数，用axios.interceptors.response.use添加响应成功和失败拦截器函数。在Axios.prototype.request函数组成promise链式调用时，Interceptors.protype.forEach遍历请求和响应拦截器添加到真正发送请求dispatchRequest的两端，从而做到请求前拦截和响应后拦截。拦截器也支持用Interceptors.protype.eject方法移除。**

3.有使用axios的取消功能吗？是怎么实现的？
本质是调用request.abort()实现的， axios实现了一个cancelToken
const { token, cancel } = axios.CancelToekn.source()
这样token和cancel就是一对，在请求中加入了token的可以直接通过cancel取消
**通过传递config配置cancelToken的形式，来取消的。判断有传cancelToken，在promise链式调用的dispatchRequest抛出错误，在adapter中request.abort()取消请求，使promise走向rejected，被用户捕获取消信息。**

5.为什么支持浏览器中发送请求也支持node发送请求？
内部实现了adpter适配器，在浏览器使用XMLHttpRequest对象，node中使用了http/https包

umi-request 包基于fetch api进行封装，支持axios能支持的所有功能


## 框架 React
### 1.react的setState,React setState 怎么获取到更新后的值？异步函数中为什么 setState 会立即更新？
答： `isBatchingUpdates`是是否异步更新的关键，异步函数isBatchingUpdates被设置成了false，所以同步更新。其余的则为异步更新
```js
// isBatchingUpdates === true ? 异步 : 同步
this.setState({a: 10}, () => {
    console.log(this.state.a)
})
// hooks的话可以写在effect中
setCounter(1)
useEffect(() => {
    // 这里是最新
    console.log(counter)
}, [counter])
```

### vue diff过程，和react diff区别
1. Vue进行diff时，调用patch打补丁函数，一边比较一边给真实的DOM打补丁
2. Vue对比节点，当节点元素类型相同，但是className不同时，认为是不同类型的元素，删除重新创建，而react则认为是同类型节点，进行修改操作
3. ①  Vue的列表比对，采用从两端到中间的方式，旧集合和新集合两端各存在两个指针，两两进行比较，如果匹配上了就按照新集合去调整旧集合，每次对比结束后，指针向队列中间移动；
 ②而react则是从左往右依次对比，利用元素的index和标识lastIndex进行比较，如果满足index < lastIndex就移动元素，删除和添加则各自按照规则调整；
 ③当一个集合把最后一个节点移动到最前面，react会把前面的节点依次向后移动，而Vue只会把最后一个节点放在最前面，这样的操作来看，Vue的diff性能是高于react的
4. react是生成一个全新的数据，用diff方法去比对state。应用的状态被改变时，全部子组件都会重新渲染。所以react中diff的是Dom.
5. Vue在渲染过程中，会跟踪每一个组件的依赖关系，不会重新渲染整个组件树，所以Vue diff的是数据。

### react事件合成
React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理
- 当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。
- 而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）
- 所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。

### vue3优化了什么？
- 语法优化，composition api，setup
- 增加teleport组件用于转移当前内容至某个元素下
```js
app.component('modal-button', {
  template: `
    <button @click="modalOpen = true">
        Open full screen modal! (With teleport!)
    </button>
    <teleport to="body">
      <div v-if="modalOpen" class="modal">
        <button @click="modalOpen = false">
        Close
        </button>
      </div>
    </teleport>
  `,
  data() {
    return {
      modalOpen: false
    }
  }
})
```
- 一个template下可以包含多个根节点！
- v-model后面可以增加参数，以及modelModifiers对象

- monorepo方式，源码通过不同的模块拆分到package，可以单独引用，方便tree-shaking
- 支持typescript
- 源码体积优化，移除冷门feature,引入tree-shaking
- 数据劫持优化，使用proxy，劫持了整个对象
- 编译优化

### vue2 性能优化
- 异步加载路由
- vif vshow使用
- computed watch 使用
- vfor 加key，避免内部还用vif
- object.freeze
- beforedestory的时候注意事件销毁
-
## 解决问题思路

### 1.选择ssr或csr的标准
ssr的优点：
- 由于返回的是整个html,首屏渲染更快
- 更利于seo
- 特别是弱网环境下有保障
缺点：
- 服务端压力比较大，高并发的时候会占用大量cpu资源
- 第三方库如果不支持ssr需要特殊处理
- ssr其实只是普通的文本，页面的可交互时间还是需要js下载完成才行
- 有些组件不支持ssr需要特殊处理
- 服务端压力会变大

总结： ssr比较适合内容密集型，csr比较适合交互密集型， ssr更适用于偏静态的内容场景

目前解决方案，使用同构渲染：即首次请求的话去服务器上请求到完整的html，js加载完成后由客户端接手

相应的降级方案：
1. 使用负载均衡，如PM2管理
2. nginx配置降级
有以下几种情况：
- 偶发性降级：偶发性的服务端渲染失败，使用客户端渲染代替
- 平台配置主动降级： 如双十一等流量大的时候配置成客户端渲染
- 监控系统降级：监控服务器cpu达到一直的阈值后降级为客户端渲染
- 渲染服务集群宕机：触发客户端渲染

还碰过那些坑？
### 4.如何编写组件兼容amd,cmd方式引用（模块化）
```js
;(function() {
    function myModule() {}

    if (typeof module !== 'undefined' && typeof exports === 'object') {
        module.exports = myModule
    } else if (typeof define  === 'function' && (define.amd || define.cmd)) {
        define(function() {return myModule})
    } else {
        this.moduleName = myModule
    }
}).call(function () { return this || (typeof window !== 'undefined' ? window : global)})
```
模块化中amd和cmd的区别：amd(require.js, 依赖前置) cmd(sea.js， 就近依赖)
动态加载js文件： Ajax + eval 的方式

### 8.页面运行一段时间变卡如何分析
分析工具：
使用chrome的performance，并record，分析原因，看看fps，fps越低越流畅
- 一般是浏览relfow产生的比较多
- 浏览器定时器之类的没有被回收
- 有内存泄漏的地方

### 9.webpack如何实现打包，webpack如何打包多页.webpack plugin异步会阻塞其他plugin吗；webpack热更新原理。webpack如何拆包？
webpack打包需要做的事情：
- 代码转换（loader）
- 文件优化 uglify tree-shaking
- 代码分割 split-chunk
- 模块合并
- 自动刷新 devserver
- 代码校验
- 自动发布
webpack打包流程：
1. 读取入口文件，生成ast,递归依赖，根据ast生成浏览器能运行的代码
2. 处理关键词 import export
3. 代码转换成浏览器能支持的，递归

多页面打包的原理就是：配置多个entry和多个HtmlWebpackPlugin
经实际操作测试，webpack异步操作会阻塞后面的plugin，相当于函数的回调一样 async await 或者promise

```js
// webpack plugin
class somePlugin {
    apply(compiler) {
        compiler.hooks.compiation.tap('somePlugin', (compiation, callback) => {
            // dosomething
        })
    }
}
```
webpack性能优化：
- 使用externals抽离第三方库，并加上cdn
- 使用HardSourceWebpackPlugin，第二次能提高90%的打包速度
- 使用new webpack.optimize.CommonsChunkPlugin(options);拆包，可以使多个入口共享一个包

webpack拆包：
```js
new webpack.optimize.CommonsChunkPlugin({
    name: 'vendor',
    minChunks: function (module, count) {
    // 将node_modules中的所有必需模块提取到verdor
    // any required modules inside node_modules are extracted to vendor
    return (
        module.resource &&
        /\.js$/.test(module.resource) &&
        module.resource.indexOf(
        path.join(__dirname, '../node_modules')
        ) === 0
    )
    }
}),
...Object.keys(chunksPackage).map(packageName => {
    return new webpack.optimize.CommonsChunkPlugin({
    name: packageName,
    chunks: ['vendor'],
    minChunks: function (module, count) {
        return module.resource && chunksPackage[packageName].filter(item => new RegExp(item).test(getModuleName(module)))[0] && count >= 1
    }
    })
}),
// extract webpack runtime and module manifest to its own file in order to
// prevent vendor hash from being updated whenever app bundle is updated
// 将webpack运行时和模块清单提取到其自己的文件中，以便每当应用程序包更新时更新供应商哈希
new webpack.optimize.CommonsChunkPlugin({
    name: 'manifest',
    chunks: Infinity,
}),
```

### 10.编写的组件如何适配amd cmd commonjs引入方式？
使用webpack打包时[使用exportloader](https://imweb.io/topic/5d1091abf7b5692b080f25a4)

### 11.前端监控

### 12.封装组件的原则
- 组件单一责任原则
- 高内聚低耦合
比如设计一个dialog组件：
1. 该组件需要提供hook指定渲染位置，默认渲染在body下面。
2. 然后改组件可以指定外层样式，如宽度等
3. 组件外层还需要一层mask来遮住底层内容，点击mask可以执行传进来的onCancel函数关闭Dialog。
4. 另外组件是可控的，需要外层传入visible表示是否可见。
5. 然后Dialog可能需要自定义头head和底部footer，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的onOk事件，然后取消按钮会执行外部传进来的onCancel事件。
6. 当组件的visible为true时候，设置body的overflow为hidden，隐藏body的滚动条，反之显示滚动条。
7. 组件高度可能大于页面高度，组件内部需要滚动条。
8. 只有组件的visible有变化且为ture时候，才重渲染组件内的所有内
### 13.axios源码
[axios源码解析](https://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&mid=2650744604&idx=1&sn=51d8d865c9848fd59f7763f5fb9ce789&chksm=88662490bf11ad86061ae76ff71a1177eeddab02c38d046eecd0e1ad25dc16f7591f91e9e3b2&mpshare=1&scene=1&srcid=&sharer_sharetime=1576629107162&sharer_shareid=9146a6b45f4b4007bda6c5a9639c1975&key=7488cac1f092ba1062f5b13a9f965fbcd8a09c16b88c30831bdc0d097b6c67dda50e9c8dae77150ae00c2cbea2168e392ad74b60442541746c86e421ba3b5b793207b0de9174cae66b4688301d72a12c&ascene=1&uin=MTk5NjAwNTQ4MQ%3D%3D&devicetype=Windows+10&version=62070158&lang=zh_CN&exportkey=AT6cFmApeLEdqRcSut5zFgI%3D&pass_ticket=1EVC1R32GDjvfeM%2Bw6REJZV9iUyD6RzsHvFzskXWUN8oFC8T%2Frzn304CxTwyOl4X)

### 15.如何技术选型
- 快速搭建原型，从经验中学习。针对新项目需要技术选型的时候，花一两天搭建原型。或者让团队不同的人来搭建原型。
- 扬长避短，关注当前选择的技术发展前景，是否能活下来
- 选择拥有强大社区支撑的项目
- 从业务端思考，比如初创项目，选择基准是灵活/快速。当业务进入稳定期，选择的基准就是可靠。当业务进入维护期，选择的基准变成了妥协。

### 16.犯过什么错? 有什么缺点？


### 17.设计模式原则
- 开放封闭原则， 对外扩展开放，对内修改关闭。
- 里氏替换原则。在任何基类可以发挥作用的地方，子类一定可以发挥作用。
- 依赖反转原则。
- 接口隔离原则。
- 最少知道原则。
- 合成复用原则。


### 18.说说单点登录
单点登录（sso时序）
- 用户未登录访问子站，子站检测用户未登录，通知浏览器跳转到sso服务站点并在url中附上当前redirect页面地址
- sso检测到用户未登录，提示用户登录。用户提交登录信息后返回token对应的cookie存下（这里需要设置cookie的path为二级域名）
- 浏览器在登录成功后把cookie带在url上返回子站点，子站点通过cookie获取用户信息并吧cookie写入浏览器
- 当用户在此访问子站点二时，检测到未登录，跳转到sso服务站点，sso服务站点携带cookie获取到用户信息实现直接登录，并返回。

### 19.扫描二维码登录
本质：
1. 告诉系统我是谁
2. 向系统证明我是谁

### 20.前端安全问题
xss
XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。
XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。
XSS 一般分为存储型、反射型和 DOM 型。
存储型指的是恶意代码提交到了网站的数据库中，当用户请求数据的时候，服务器将其拼接为 HTML 后返回给了用户，从而导致了恶意代码的执行。
反射型指的是攻击者构建了特殊的 URL，当服务器接收到请求后，从 URL 中获取数据，拼接到 HTML 后返回，从而导致了恶意代码的执行。
DOM 型指的是攻击者构建了特殊的 URL，用户打开网站后，js 脚本从 URL 中获取数据，从而导致了恶意代码的执行。
XSS 攻击的预防可以从两个方面入手，一个是恶意代码提交的时候，一个是浏览器执行恶意代码的时候。
对于第一个方面，如果我们对**存入数据库的数据都进行的转义处理**，但是一个数据可能在多个地方使用，有的地方可能不需要转义，由于我们没有办法判断数据最后的使用场景，所以直接在输入端进行恶意代码的处理，其实是不太可靠的。
因此我们可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回。另一种是对**需要插入到 HTML 中的代码做好充分的转义**。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，我们对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。
还有一些方式，比如使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
还可以对一些敏感信息进行保护，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。

csrf
CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被
攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。
CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。
一般的 CSRF 攻击类型有三种：
第一种是 GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提
交。
第二种是 POST 类型的 CSRF 攻击，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
第三种是链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。

CSRF 可以用下面几种方法来防护：
- 第一种是**同源检测**的方法，服务器根据 http 请求头中 `origin` 或者 `referer` 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。
- 第二种方法是使用 **CSRF Token 来进行验证**，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。
- 第三种方式使用**双重 Cookie 验证**的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
- 第四种方式是使用在**设置 cookie 属性的时候设置 Samesite** ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。

 ### koa 洋葱模型原理， compose原理
本质上就是一个compose，但是使用了koa-promise
洋葱模型，先进后出，类似递归
而express并没有对promise针对性的处理，请求是否发送取决于合适调用send方法

## express和koa的区别
1. 编码风格：express采用回调函数风格，koa1 采用 generator，koa2(默认)使用await，风格上更加优雅，koa与es6,7的结合更加紧密;
2. 错误处理：express采用在回调中错误优先的处理方式，深层次的异常捕获不了，使得必须在每一层回调里面处理错误，koa的使用try catch捕获错误，将错误上传可以统一处理错误;
3. Koa 把 Express 中内置的 router、view 等功能都移除了，使得框架本身更轻量;
4. express社区较大，文档也相对较多，koa社区相对较小;

```js
function compose(middleware) {
    return function(context, next) {
        let index = -1;
        function disipatch(i) {
            index = i;
            let fn = middleware[i];
            if (i === middleware.length) fn = next
            // 退出条件
            if (!fn) return Promise.resolve()
            try {
                return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
            } catch(e) {
                return Promise.reject(e)
            }
        }
        return dispatch(0)
    }
}
```

### 问题`'1 2 3'.replace(/\d/g, parseInt)`的结果
答案： 1 NaN 3
解析，相当于
```js
// 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。
parseInt('1', 0) // 如果省略该参数或其值为 0，则数字将以 10 为基础来解析, 所以是十进制 1
parseInt('2', 2) // 二进制只有0和1，所以是NaN
parseInt('3', 4) // 4 > 3 所以正常返回3，如果 4的话就会变成NaN
// [1 < 2 < 3, 3 < 2 < 1]
// 1 < 2 < 3
// => false < 3 => true
// 3 < 2 < 1
// => false < 1 => true
let s = new String('A')
switch(s){
    case 'A':
    console.log('A')
    break;
    case undefined:
    console.log(undefined)
    default:
    console.log('dont know')
    break;
}

// 结果是dont know
```

### try catch 是否能捕获promise内的报错？
答： 经实际操作，catch内能捕获报错，但是浏览器仍然会报错

### iconfont如何实现的？
答：iconfont的使用有三种方法：
1. Unicode引用方式
就是直接引用字体对应的unicode的码，
```html
<i class="testfont">&#xe869;</i>
```
```css
@font-face{
    font-family: testfont;
    src: url('Sansation_Light.ttf');
}
.testfont{
  font-family:"testfont" !important;
  font-size:16px;
  font-style:normal;
  -webkit-font-smoothing: antialiased;
  -webkit-text-stroke-width: 0.2px;
  -moz-osx-font-smoothing: grayscale;
}
```
2. Font class方式引用
在第一种方式的基础上，使用伪类引用字体文件对应的unicode码生成。
在原来的dom上增加一个伪元素，css中正斜杠\表示一个16进制数字。这样写的好处是可以直接通过审查dom元素就知道它引用的是哪个字形，看起来更加语义化。
```html
<i class="testfont test-socialchrome"></i>
```
```css
@font-face{
    font-family: testfont;
    src: url('Sansation_Light.ttf');
}
.test-socialchrome:before {
  content: "\e869";
}
```
3. Symbol的方式引用
每个图标是一个svg，每个svg都有对应的id，使用的时候用useid就可以了，这样其实可以封装成一个icon字体
把图标元素的宽高都写为1em，而em的大小是相对于该元素的字体大小的
```html
<svg class="icon" aria-hidden="true">
    <use xlink:href="#test-xxxx"></use>
</svg>
```

### tree-shaking原理
deadcode: 死代码
- 代码不会被执行，不可到达
- 代码执行结果不会被用到
- 代码只会影响死变量

tree-shaking的消除原理是依赖于ES6的模块特性
ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，这就是tree-shaking的基础。
所谓静态分析就是不执行代码，从字面量上对代码进行分析，ES6之前的模块化，比如我们可以动态require一个模块，只有执行后才知道引用的什么模块，这个就不能通过静态分析去做优化。
那对于commonjs如何tree-shaking

### 一个tcp链接可以发送多少个http请求
1.0 一个
1.1 keep-alive 不限
2.0 多路复用，不限制

### websocket 如何保持连接
tornado不设置websocket_ping_interval的话，就没法保持长连接
保持长连接有两种方式，一种是TCP keepalive. 还有一种 ping/pong。 我测试下来, chrome和firefox websocket 会不间断发送 TCP keepalive。 所以并不要需要启用tornado的ping机制。

### 现在按照一定顺序发起去进行第三方渠道授权多个异步网络请求（未知数量，需设数组），但每个网络请求如果报错了或者失败了有多次请求的机会（次数可设置），直到当前网络请求节点的次数用完了，才算授权调用链失败，需要封装一个函数，返回promise课直到整体调用链完成情况以及每个节点的数据。

### 如何用js实现对上传图片进行压缩？
[文章出处](https://www.zhangxinxu.com/wordpress/2017/07/html5-canvas-image-compress-upload/)
使用canvas 的drawimg api进行压缩

```js
// 清除画布
context.clearRect(0, 0, targetWidth, targetHeight);
// 图片压缩
context.drawImage(img, 0, 0, targetWidth, targetHeight);
// 转成base64
canvas.toDataURL(mimeType, qualityArgument) // canvas.toDataURL('image/jpeg', 0.8)
// 转成blob对象
canvas.toBlob(callback, mimeType, qualityArgument) // canvas.toBlob((blob) => {}, 'image/jpeg', 0.8)
```

## 微服务装载和卸载
主框架配置子应用的路由为subApp: { url: '/subApp/**', entry:'./subApp.js' }，则当浏览器的地址为 /subApp/abc 时，框架需要先加载 entry 资源，待 entry 资源加载完毕，确保子应用的路由系统注册进主框架之后后，再去由子应用的路由系统接管 url change 事件。同时在子应用路由切出时，主框架需要触发相应的destroy 事件，子应用在监听到该事件时，调用自己的卸载方法卸载应用，如 React 场景下 destroy = () => ReactDOM.unmountAtNode(container) 。
### 微服务的问题1： 如何应用隔离？
css隔离：
1. 通过shaown Dom的方式，确定，如果子应用中出现运行时越界跑到外面构建 DOM 的场景必定会导致构建出来的 DOM 无法应用子应用的样式的情况。如弹窗
2. css Module BEM 的问题： 约定的方式有一个无法解决的问题，假如子应用中使用了三方的组件库，三方库在写入了大量的全局样式的同时又不支持定制化前缀？比如 a 应用引入了 antd 2.x，而b 应用引入了 antd 3.x，两个版本的 antd 都写入了全局的 .menu class ，但又彼此不兼容怎么办？
3. 最终解决方案： Dynamic Stylesheet 。我们只需要在应用切出/卸载后，同时卸载掉其样式表即可，原理是浏览器会对所有的样式表的插入、移除做整个 CSSOM 的重构，从而达到 插入、卸载 样式的目的。HTML Entry 方案则天生具备样式隔离的特性，因为应用卸载后会直接移除去 HTML 结构，从而自动移除了其样式表。
js隔离：
js沙箱方案


### webp格式如何兼容？
客户端 --> 请求图片资源 --> 判断是否支持webp -是-> cdn是否缓存有webp副本 -是-> 返回webp格式副本
                                        -否-> 返回原图             -否-> 实时生成webp副本并返回，并在cdn节点缓存

cdn如何判断浏览器是否支持webp？
CDN 是通过 HTTP Accept 头来判断的，如果支持，则返回 WebP 副本并进行缓存；如果不支持，则返回原图。
以 Chrome 浏览器为例：
`accept:image/webp,image/apng,image/*,*/*;q=0.8`
如上列表可以看出，当 Accept 请求头里面如果有 image/webp 字段，则说明客户端支持 WebP 解码。

cdn如何实现实时图片格式转换？
- 客户端浏览器请求一个图片资源，例如：http://webp.example.com/test.png;
- CDN 通过 Accept 头已经判断客户端浏览器支持 WebP 格式的图片；
- CDN 回用户源站取回原图并将原图实时转为 WebP 格式的图片，并响应给客户端���览器。
- 原图访问 ，示例：/a.jpg
- 自定义版本号作图，示例：/a.jpg!123
- URL 作图 ，示例：/a.jpg!/format/webp
- 自定义版本号 + URL 作图：/a.jpg!123/format/webp

```html
<!-- 解决不同分辨率下不同显示不同质量图片 一 -->
<picture>
  <source media="(min-width: 650px)" srcset="demo1.jpg">
  <source media="(min-width: 465px)" srcset="demo2.jpg">
  <img src="img_girl.jpg">
</picture>
```
```html
<img srcset="" />
```

### 小程序和h5的区别
线程：
网页开发渲染现场和脚本线程是互斥的，长时间的脚本运行会导致页面失去响应。
小程序中二者分布在不同线程中。
逻辑层
小程序逻辑层运行在jscore中，没有完整的浏览器对象
网页逻辑层是v8引擎
渲染层：
网页面对的是浏览器，小程序面对的主要是ios Android的微信客户端，以及用于辅助开发的小程序客户端
小程序需要申请小程序账号，安装小程序开发者工具，配置项目等过程才能访问。

## 前端性能优化
 前端性能优化主要是为了提高页面的加载速度，优化用户的访问体验。我认为可以从这些方面来进行优化。
 第一个方面是页面的内容方面
 （1）通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况。
 （2）通过 DNS 缓存等机制来减少 DNS 的查询次数。
 （3）通过设置缓存策略，对常用不变的资源进行缓存。
 （4）使用延迟加载的方式，来减少页面首屏加载时需要请求的资源。延迟加载的资源当用户需要访问时，再去请求加载。
 （5）通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度。

 第二个方面是服务器方面
 （1）使用 CDN 服务，来提高用户对于资源请求时的响应速度。
 （2）服务器端启用 Gzip、Deflate 等方式对于传输的资源进行压缩，减小文件的体积。
 （3）尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie

 第三个方面是 CSS 和 JavaScript 方面
 （1）把样式表放在页面的 head 标签中，减少页面的首次渲染的时间。
 （2）避免使用 @import 标签。
 （3）尽量把 js 脚本放在页面底部或者使用 defer 或 async 属性，避免脚本的加载和执行阻塞页面的渲染。
        - 细节：设置defer的脚本，是DOMContentLoaded 先执行还是defer先执行，在chrome种是defer先执行在执行DOMContentLoaded事件（已测试）
        - 细节：如果在js文件中存在大量的计算会阻塞layout阶段运行，不管defer还是body后都一样（已测试）
        - 细节： defer并不能解决js计算量很大的问题，需要展示首屏还是得把大量计算放在DOMContentLoaded事件中
 （4）通过对 JavaScript 和 CSS 的文件进行压缩，来减小文件的体积。

 使用video替换gif图片，可以使用(**FFmpeg**) `$ ffmpeg -i input.mp4 output.avi`
 一般来说gif比video还大，video可以使用webm，mp4等格式 并移除不必要的音轨信息
 渲染层合并

经测试：延时加载css就是等css加载到了就回流

计算首屏时间如果没有图片趋向于使用domready时间：
```js
function fristScreen() {
    const imgs = document.getElementsByTag('img')
    const fsItems = []
    const loadEvent = function() {
        let curTime = +new Date()
        this.removeEventListener('load', loadEvent, false)
        fsItems.push({
            img: this,
            time: curTime,
            top: this.getBoundingRect().top + document.documentElement.scrollTop
        })
    }

    imgs.forEach((img) => {
        img.addEventListener('load', loadEvent, false)
    })
    // 计算首屏时间如果没有图片趋向于使用domready时间
    const times = fsItems.filter((item) => item.top < document.documentElement.clientHeight).map((item) => item.time)
    const maxTime = Math.max(...times, performance.timing.navigationStart - performance.timing.domInteractive)

    return maxTime;
}
```
FPS，如何计算fps
正常而言，如果不掉帧，requesAnimationFrame这个api会在1s内执行60次。那计算真实fps也就是requesAnimationFrame执行了多少次

```js
function calcFps(debounce = 1000) {
    let lastTime = Date.now()
    let count = 0

    (function loop() {
        count++
        const num = Date.now() - lastTime
        if (num > debounce) {
            // 转换成秒
            const fps = Math.round(count / (num / debounce))
            lastTime = now
            count = 0
            console.log('fps：', fps)
        }
    })()
}
```
### 性能监控/性能优化
性能监控的工具：
- lighthourse 跑分
- pagespeed 跑分
- web-vitals-extension 跑分
- web-vitals库
- 性能魔方（http://blog.mmtrix.com/） 跑分

性能指标
`白屏`、`首屏`、`domready`和`pageloaded`

关键渲染路径（CRP）（Critical Rendering Path）： 浏览器请求html文档到首次渲染到屏幕上所需做的步骤叫做关键渲染路径。
- 获取所有阻塞资源（关键资源）所需的往返次数， 比如说样式文件， 脚本文件
- 例如： DNS解析(T1) -> 建立TCP连接(T2) -> 发送请求(T3) -> 等待服务器返回首字节（TTFB）(T4) -> 接收数据(T5)。

### 性能优化指标
- TTFB(Time to First Byte): 第一个字节的时间，从点击到收到第一个字节的时间
    - 什么原因？
    1. 服务型性能不好 : 升级服务器
    2. 服务器优化不好 : 进了缓存一些sql，减少查询
    3. 携带字段过多（cookie太大等）: 浏览器的一些插件
- FP(First Paint):第一次绘制，用户第一次看到任何像素内容的时间
- **FCP**(First Content Paint): 第一次内容绘制，用户看到第一次有效内容的时间  connectStart
- FSP: 第一屏内容绘制的的时间
- TTI(Time to Interactive):可交互时间
- **LCP**(Largest Contentful Paint):第一次最大内容绘制 用户看到最大内容的时间
- **FID**(First Input Delay): 记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟。应维持在100ms以内。
- **CLS**(Cumulative Layout Shift): 页面上非预期的位移波动。

首屏时间，白屏时间，首次可交互时间

- 压缩文件、使用 Tree-shaking 删除无用代码服务端配置
- Gzip 进一步再压缩文件体积资源按需加载通过
- Chrome DevTools 分析首屏不需要使用的 CSS 文件，以此来精简
- CSS内联关键的 CSS 代码使用 CDN 加载资源及
- `dns-prefetch` 预解析 DNS 的 IP 地址
- 对资源使用 `preconnect`，以便预先进行 IP 解析、TCP 握手、TLS 握手
- 缓存文件，对首屏数据做离线缓存
- 图片优化，包括：用 CSS 代替图片、裁剪适配屏幕的图片大小、小图使用 base64 或者 PNG 格式、支持 WebP 就尽量使用 WebP、渐进式加载图片
- 使用 Web Worker 将耗时任务丢到子线程中，这样能让主线程在不卡顿的情况下处理 JS 任务
- 调度任务 + 时间切片，这块技术在 React 16 中有使用到。简单来说就是给不同的任务分配优先级，然后将一段长任务切片，这样能尽量保证任务只在浏览器的空闲时间中执行而不卡顿主线程

优化CLS(Cumulative Layout Shift)
- 使用骨架屏给用户一个预期的内容框架，突兀的显示内容体验不会很好
- 图片切勿不设置长宽，而是使用占位图给用户一个图片位置的预期
- 不要在现有的内容中间插入内容，起码给出一个预留位置

查找域名： 开始查找域名到查找结束 domainLookupEnd - domainLookupStart
建立链接：开始发送请求到连接成功 connectEnd - connectStart
请求文档：开始请求文档到开始接收文档 responseStart - resquestStart
接收文档：开始接收文档到文档接收完成 responseEnd - responseStart
domready: 开始解析文档到DOMContentLoaded事件被触发 domContentLoadedEventStart - domLoading
load事件持续： load事件被触发到load事件完成 loadEventEnd - loadEventStart
完全加载：开始解析文档到文档完全加载 domComplete - domLoading
首屏加载：开始解析文档到首屏加载完毕 firstscreenready - domLoading
完全加载：此次浏览器最开始时刻到完全加载完毕 domComplete - navigatorStart
首屏加载：此次浏览器最开始时刻到首屏加载完毕 firstscreenready - navigatorStart

```js
// performance的api
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log(entry)
  }
});
// 监听下列事件返回的性能时间
observer.observe({entryTypes: ['resource', 'paint', 'longtask', 'measure']});

// mark measure
performance.mark('a');
performance.measure('aa');
```

### 合并请求和不合并请求并行请求的区别
- 对于大资源，是否合并对于加载时间没有明显影响，但拆分资源可以更好的利用浏览器缓存，不会因为某个资源的更新导致所有资源缓存失效，而资源合并后，任一资源的更新都会导致整体资源的缓存失效。另外还可以利用域名分片技术，将资源拆分部署到不同域名下，既可以分散服务器的压力，又可以降低网络抖动带来的影响。
- 对于小资源，合并资源往往具有更快的加载速度，但在网络带宽状况良好的情况下，因为提升的时间单位以ms计量，收益可以忽略。如果网络延迟很大，服务器响应速度又慢，则可以带来一定收益，但在高延迟的网络场景下，又要注意合并资源后可能带来网络往返次数的增加，进而影响到加载时间。

### css是否阻塞dom渲染的问题
css后面不存在任何js代码时：
css还未加载完，就已经触发了DOMContentLoaded事件了。或者js在css前面时。
css后面存在js代码时：
css加载完成才会触发DOMContentLoaded
结论：
- 如果页面中同时存在css和js，并且存在js在css后面，则DOMContentLoaded事件会在css加载完后才执行。
- 其他情况下，DOMContentLoaded都不会等待css加载，并且DOMContentLoaded事件也不会等待图片、视频等其他资源加载。
- 当css还没加载出来的时候，页面显示白屏，直到css加载完成之后，红色字体才显示出来，也就是说，下面的内容虽然解析了，但是并没有被渲染出来。所以，css加载会阻塞DOM树渲染。
- css加载会阻塞后面的js语句的执行

解决css加载慢一闪的问题：
- 使用cdn
- css压缩
- http缓存
- 合并css


### dns-prefetch、prerender、prefetch、preload的区别
dns-prefetch:
```html
<!-- 开启DNS预获取 -->
<meta http-equiv="x-dns-prefetch-control" content="on">
<!-- 设置DNS预获取的域名 -->
<link rel="dns-prefetch" href="//g.alicdn.com" />
```
preconnect：
浏览器要建立一个连接，需要经过DNS查找，TCP三次握手和TLS协商（https需要)，这些过程需要相当的耗时，所以preconnect，就是一项使浏览器预先建立一个连接（包含DNS查找，TCP三次握手和TLS协商)，等真正需要加载资源的时候能直接请求；
```html
<link rel="preconnect" href="//example.com">
<link rel="preconnect" href="//cdn.example.com" crossorigin>
```
preload:
浏览器会在遇到如下link标签时，立刻开始下载main.js(不阻塞 non-render-blocking )，并放在内存中，但不会执行其中的JS语句。只有当遇到script标签加载的也是main.js的时候，浏览器才会直接将预先加载的JS执行掉。
```html
<!-- 跨域请求文件需要设置crossorigin, 如果是字体文件即使不跨域也需要设置 -->
<link rel="preload" href="fonts/cicle_fina-webfont.eot" as="font" type="application/vnd.ms-fontobject" crossorigin="anonymous">
```
prefetch:
设置此值能让浏览器预加载一个资源（html，js，css或图片），可以让用户跳转到其他页面时，响应速度更快。
```html
<link rel="prefetch" href="//example.com/next-page.html" as="html" crossorigin="use-credentials">
<link rel="prefetch" href="/library.js" as="script">
```
prerender:
而prerender不仅会加载资源，还会解**执行页面，进行预渲染**，但是这都是根据浏览器自身进行判断。
```html
<link rel="prerender" href="//example.com/next-page.html">
```
## TypeScript
### ts中关键字infer
- infer只能用于extends语句中
```ts
// infer 的作用是让 TypeScript 自己推断，并将推断的结果存储到一个类型变量中
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any

type Flatten<T> = T extends Array<infer U> ? U : never
type T0 = [string, number]
type T1 = Flatten<T0> // string | number
// 下面这个
type TypeTuple = [string, number]
type TypeArray = Array<string | number>
type B0 = TypeTuple extends TypeArray ? true : false // true
```

```ts
// ts中的高级用法
// 将类型 T 的所有属性标记为可选属性
type Partial<T> = {
    [P in keyof T]?: T[P];
};
// 将类型 T 的所有属性标记为必选属性
type Required<T> = {
    [P in keyof T]-?: T[P];
};
// 将所有类型都变成只读
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};
// 从T中过滤出K
type Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};
// 标记对象的 key value类型
type Record<K extends keyof any, T> = {
    [P in K]: T;
};
// 移除T中的U属性
type Exclude<T, U> = T extends U ? never : T;
// exclude的反向操作
type Extract<T, U> = T extends U ? T : never;
// pick的反向操作
type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>

type NonNullable<T> = T extends null | undefined ? never : T;

// 获取一个函数的所有参数类型
// 此处使用 infer P 将参数定为待推断类型
// T 符合函数特征时，返回参数类型，否则返回 never
type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;
import {somefun} from 'somelib'
// 从其他库导入的一个函数，获取其参数类型
type SomeFuncParams = Parameters<typeof somefun>
// 内置函数
// [any, number?, number?]
type FillParams = Parameters<typeof Array.prototype.fill>


```

### any 和unknown 和 never有什么区别？
any: 任意类型
void: 无任意类型 -> 如果是函数则应没有返回值或者返回 undefined
unknown: 未知类型 -> 写代码的时候还不清楚会得到怎样的数据类型，如服务器接口返回的数据，`JSON.parse()` 返回的结果等,该类型只能赋值给unknow 或者 any类型
never: 永不存在的值 -> 从程序运行的维度讲，如果一个函数执行时抛出了异常，那么这个函数变永远不会有值了；函数中执行无限循环的代码（死循环） 永远不能给它赋值

### Worker家族， ServerWorker, ShareWorker, WebWorker

### 浏览器架构：
cpu: Central Processing Unit
gpu: Graphics Processing Unit
IPC: Inter Process Communication
计算机自下而上分成三层：硬件、操作系统和应用
一个进程是应用正在运行的程序。而线程是进程中更小的一部分。协程，而协成是运行在线程中更小的单位。async/await 就是基于协程实现的。
- chrome打开四个进程分别是什么？
1. 浏览器进程
    - 浏览器进程负责管理 Chrome 应用本身，包括地址栏、书签、前进和后退按钮。同时也负责可不见的功能，比如网络请求、文件按访问等，也负责其他进程的调度。
2. 网络进程
3. gpu进程
    - GPU 进程负责提供成像的功能。
4. 渲染进程
    - 渲染进程负责站点的渲染，其中也包括 JavaScript 代码的运行，web worker 的管理等。

### 前端页面闪烁解决方案
1. 如果是vue项目，可以使用v-clock
2. 使用loading效果
<!-- 3.  -->

### new Function 的用法
- 当使用new Function()创建函数时，其[[Environment]]不是引用当前的词法环境，而是引用全局环境。
- 当new Function() 中使用到外部变量，而外部变量被压缩时就会有问题，它找不到外部变量了
```js
new Function('a', 'b', 'return a + b')
// 相当于
function(a, b) { return a + b }
// 最后一个是函数体，前面的都是参数
```

